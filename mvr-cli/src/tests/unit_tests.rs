use anyhow::Result;
use expect_test::expect;
use mvr::{
    build_lock_files, check_address_consistency, get_published_ids, parse_package_version, GitInfo,
    PackageInfo, PackageInfoNetwork,
};
use std::collections::HashMap;
use std::fs;
use sui_sdk::types::base_types::ObjectID;
use tempfile::tempdir;

fn create_resolved_packages() -> HashMap<String, PackageInfo> {
    let mut resolved_packages = HashMap::new();
    resolved_packages.insert(
        "@mvr-test/first-app/1".to_string(),
        PackageInfo {
            upgrade_cap_id: ObjectID::random(),
            package_address: ObjectID::from_hex_literal("0x1234567890abcdef").unwrap(),
            git_versioning: {
                let mut map = HashMap::new();
                map.insert(
                    1,
                    GitInfo {
                        repository: "https://github.com/example/demo.git".to_string(),
                        tag: "v1.0.0".to_string(),
                        path: "packages/demo".to_string(),
                    },
                );
                map
            },
        },
    );
    resolved_packages
}

#[tokio::test]
async fn test_build_lock_files() -> Result<()> {
    let temp_dir = tempdir()?;
    let move_toml_content = r#"
[package]
name = "demo"
edition = "2024.beta"

[dependencies]
Sui = { git = "https://github.com/MystenLabs/sui.git", subdir = "crates/sui-framework/packages/sui-framework", rev = "framework/mainnet" }

[addresses]
demo = "0x0"
"#;

    let move_lock_content = r#"# @generated by Move, please check-in and do not edit manually.

[move]
version = 3
manifest_digest = "0"
deps_digest = "0"
dependencies = [
  { id = "Sui", name = "Sui" },
]

[[move.package]]
id = "MoveStdlib"
source = { git = "https://github.com/MystenLabs/sui.git", rev = "framework/mainnet", subdir = "crates/sui-framework/packages/move-stdlib" }

[[move.package]]
id = "Sui"
source = { git = "https://github.com/MystenLabs/sui.git", rev = "framework/mainnet", subdir = "crates/sui-framework/packages/sui-framework" }

dependencies = [
  { id = "MoveStdlib", name = "MoveStdlib" },
]
"#;

    let move_toml_path = temp_dir.path().join("Move.toml");
    let move_lock_path = temp_dir.path().join("Move.lock");
    fs::write(&move_toml_path, move_toml_content)?;
    fs::write(&move_lock_path, move_lock_content)?;

    let resolved_packages = create_resolved_packages();
    let mut fetched_files = HashMap::new();
    fetched_files.insert(
        "@mvr-test/first-app/1".to_string(),
        (move_toml_path, move_lock_path),
    );
    let result = build_lock_files(&resolved_packages, &fetched_files).await?;

    // Note: roots "demo" in `move.dependencies` and creates a [move.package.source] entry for the demo package.
    expect![[r##"
        # @generated by Move, please check-in and do not edit manually.

        [move]
        version = 3
        manifest_digest = "0"
        deps_digest = "0"
        dependencies = [{ name = "demo", id = "demo" }]

        [[move.package]]
        id = "MoveStdlib"
        source = { git = "https://github.com/MystenLabs/sui.git", rev = "framework/mainnet", subdir = "crates/sui-framework/packages/move-stdlib" }

        [[move.package]]
        id = "Sui"
        source = { git = "https://github.com/MystenLabs/sui.git", rev = "framework/mainnet", subdir = "crates/sui-framework/packages/sui-framework" }

        dependencies = [
          { id = "MoveStdlib", name = "MoveStdlib" },
        ]

        [[move.package]]
        id = "demo"
        dependencies = [
          { id = "Sui", name = "Sui" },
        ]

        [move.package.source]
        git = "https://github.com/example/demo.git"
        rev = "v1.0.0"
        subdir = "packages/demo"
    "##]]
    .assert_eq(&result[0]);
    Ok(())
}

#[tokio::test]
async fn test_parse_package_version() -> Result<()> {
    let result = parse_package_version("@foo/bar/1")?;
    expect![[r#"
        (
            "@foo/bar",
            Some(
                1,
            ),
        )
    "#]]
    .assert_debug_eq(&result);

    let result = parse_package_version("foo/bar")?;
    expect![[r#"
        (
            "foo/bar",
            None,
        )
    "#]]
    .assert_debug_eq(&result);

    let result = parse_package_version("@foo/bar")?;
    expect![[r#"
        (
            "@foo/bar",
            None,
        )
    "#]]
    .assert_debug_eq(&result);

    let result = parse_package_version("@foo/bar/baz");
    expect![[r#"
        Err(
            "Invalid name format: @foo/bar/baz",
        )
    "#]]
    .assert_debug_eq(&result);

    let result = parse_package_version("@foo/bar/0");
    expect![[r#"
        Ok(
            (
                "@foo/bar",
                Some(
                    0,
                ),
            ),
        )
    "#]]
    .assert_debug_eq(&result);
    Ok(())
}

#[tokio::test]
async fn test_check_address_consistency() -> Result<()> {
    let temp_dir = tempdir()?;
    ///////////////
    // Move.toml //
    ///////////////
    let move_toml_content = r#"
[package]
name = "demo"
version = "0.0.1"

[addresses]
demo = "0x0"
"#;

    ///////////////
    // Move.lock //
    ///////////////
    let move_lock_content = r#"
[move]
version = 3
dependencies = [
  { name = "Sui", addr = "0x2" },
]

[env]

[env.testnet]
chain-id = "4c78adac"
original-published-id = "0x1234567890abcdef"
latest-published-id = "0x1234567890abcdef"
published-version = "1"
"#;

    let move_toml_path = temp_dir.path().join("Move.toml");
    let move_lock_path = temp_dir.path().join("Move.lock");
    fs::write(&move_toml_path, move_toml_content)?;
    fs::write(&move_lock_path, move_lock_content)?;

    let resolved_packages = create_resolved_packages();
    let mut fetched_files = HashMap::new();
    fetched_files.insert(
        "@mvr-test/first-app/1".to_string(),
        (move_toml_path.clone(), move_lock_path.clone()),
    );
    ////////////////////////////////////////////////////////////////////////////////////////////
    // Expect success: Move.lock matches expected resolved address.                           //
    ////////////////////////////////////////////////////////////////////////////////////////////
    let network = PackageInfoNetwork::Testnet;
    let result = check_address_consistency(&resolved_packages, &network, &fetched_files).await;
    expect![[r#"
        Ok(
            (),
        )
    "#]]
    .assert_debug_eq(&result);

    ////////////////////////////////////////////////////////////////////////////////////////////
    // Expect failure: Move.lock does not match resolved address.                             //
    ////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////
    // Move.lock //
    ///////////////
    let move_lock_content = r#"
[move]
version = 3
dependencies = [
  { name = "Sui", addr = "0x2" },
]

[env]

[env.testnet]
chain-id = "4c78adac"
original-published-id = "0xbad"
latest-published-id = "0xbad"
published-version = "1"
"#;

    let move_lock_path = temp_dir.path().join("Move.lock");
    fs::write(&move_lock_path, move_lock_content)?;
    fetched_files.insert(
        "@mvr-test/first-app/1".to_string(),
        (move_toml_path.clone(), move_lock_path),
    );
    let result = check_address_consistency(&resolved_packages, &network, &fetched_files).await;
    expect![[r#"
        Err(
            "Mismatch: The original package address for @mvr-test/first-app on testnet is 0x0000000000000000000000000000000000000000000000001234567890abcdef, but the Move.lock in @mvr-test/first-app's repository was found to be 0x0000000000000000000000000000000000000000000000000000000000000bad.\nCheck the configuration of the package's repository https://github.com/example/demo.git in branch v1.0.0 in subdirectory packages/demo",
        )
    "#]]
    .assert_debug_eq(&result);

    ////////////////////////////////////////////////////////////////////////////////////////////
    // Expect failure: no published address (empty lock and no address in Move.toml)          //
    ////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////
    // Move.lock //
    ///////////////
    let move_lock_content = r#"
[move]
version = 3
dependencies = [
  { name = "Sui", addr = "0x2" },
]
"#;

    let move_lock_path = temp_dir.path().join("Move.lock");
    fs::write(&move_lock_path, move_lock_content)?;
    fetched_files.insert(
        "@mvr-test/first-app/1".to_string(),
        (move_toml_path.clone(), move_lock_path.clone()),
    );
    let result = check_address_consistency(&resolved_packages, &network, &fetched_files).await;
    expect![[r#"
        Err(
            "Mismatch: The original package address for @mvr-test/first-app on testnet is 0x0000000000000000000000000000000000000000000000001234567890abcdef, but the address in the [addresses] section of the Move.toml in @mvr-test/first-app's repository was found to be 0x0000000000000000000000000000000000000000000000000000000000000000.\nCheck the configuration of the package's repository https://github.com/example/demo.git in branch v1.0.0 in subdirectory packages/demo",
        )
    "#]]
    .assert_debug_eq(&result);

    ////////////////////////////////////////////////////////////////////////////////////////////
    // Expect success: address resolved from published-at (0x0 in [addresses]                 //
    ////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////
    // Move.toml //
    ///////////////
    let move_toml_content = r#"
[package]
name = "demo"
published-at = "0x1234567890abcdef"
version = "0.0.1"

[addresses]
demo = "0x0"
"#;

    let move_toml_path = temp_dir.path().join("Move.toml");
    fs::write(&move_toml_path, move_toml_content)?;
    fetched_files.insert(
        "@mvr-test/first-app/1".to_string(),
        (move_toml_path, move_lock_path.clone()),
    );
    let result = check_address_consistency(&resolved_packages, &network, &fetched_files).await;
    expect![[r#"
        Ok(
            (),
        )
    "#]]
    .assert_debug_eq(&result);

    ////////////////////////////////////////////////////////////////////////////////////////////
    // Expect success: address resolved from [addresses] (published-at is upgraded pkg addr)  //
    ////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////
    // Move.toml //
    ///////////////
    let move_toml_content = r#"
[package]
name = "demo"
published-at = "0xabcdef"
version = "0.0.1"

[addresses]
demo = "0x1234567890abcdef"
"#;

    let move_toml_path = temp_dir.path().join("Move.toml");
    fs::write(&move_toml_path, move_toml_content)?;
    fetched_files.insert(
        "@mvr-test/first-app/1".to_string(),
        (move_toml_path, move_lock_path),
    );
    let result = check_address_consistency(&resolved_packages, &network, &fetched_files).await;
    expect![[r#"
        Ok(
            (),
        )
    "#]]
    .assert_debug_eq(&result);
    Ok(())
}

#[tokio::test]
async fn test_get_published_ids() -> Result<()> {
    // Case (1): Move.toml with published-at and addresses.
    let move_toml_content = r#"
[package]
name = "demo"
published-at = "0xabcdef"

[addresses]
demo = "0x1234567890abcdef"
"#;
    let original_address_on_chain = ObjectID::from_hex_literal("0x1234567890abcdef")?;
    let result = get_published_ids(move_toml_content, &original_address_on_chain).await;
    expect![[r#"
        MoveTomlPublishedID {
            addresses_id: Some(
                "0x1234567890abcdef",
            ),
            published_at_id: Some(
                "0xabcdef",
            ),
            internal_pkg_name: Some(
                "demo",
            ),
        }
    "#]]
    .assert_debug_eq(&result);

    // Case (2): Move.toml with only published-at.
    let move_toml_content = r#"
[package]
name = "demo"
published-at = "0x1234567890abcdef"
"#;
    let result = get_published_ids(move_toml_content, &original_address_on_chain).await;
    expect![[r#"
        MoveTomlPublishedID {
            addresses_id: None,
            published_at_id: Some(
                "0x1234567890abcdef",
            ),
            internal_pkg_name: None,
        }
    "#]]
    .assert_debug_eq(&result);

    // Case (3): Move.toml with only addresses and 0x0 (e.g., automated address management in use).
    let move_toml_content = r#"
[package]
name = "demo"

[addresses]
demo = "0x0"
"#;
    let result = get_published_ids(move_toml_content, &original_address_on_chain).await;
    expect![[r#"
        MoveTomlPublishedID {
            addresses_id: Some(
                "0x0",
            ),
            published_at_id: None,
            internal_pkg_name: Some(
                "demo",
            ),
        }
    "#]]
    .assert_debug_eq(&result);

    // Case (4): Move.toml with only addresses and not 0x0.
    let move_toml_content = r#"
[package]
name = "demo"

[addresses]
demo = "0x1234567890abcdef"
"#;
    let result = get_published_ids(move_toml_content, &original_address_on_chain).await;
    expect![[r#"
        MoveTomlPublishedID {
            addresses_id: Some(
                "0x1234567890abcdef",
            ),
            published_at_id: None,
            internal_pkg_name: Some(
                "demo",
            ),
        }
    "#]]
    .assert_debug_eq(&result);

    Ok(())
}
